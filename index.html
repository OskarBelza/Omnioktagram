<!DOCTYPE html>
<html lang="pl">
<link rel="preload" href="static/fonts/Centurion.ttf" as="font" type="font/ttf" crossorigin="anonymous">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Omnioktagram</title>
    <link rel="stylesheet" href="static/styles.css">
    <style>
    @font-face {
      font-family: 'Centurion';
      src: url('static/fonts/Centurion.ttf') format('truetype');
    }
    </style>
</head>
<body>
    <button id="toggleTheme" class="theme-toggle" title="PrzeÅ‚Ä…cz tryb">
        ðŸŒ—
    </button>
    <h1>Omnioktagram</h1>
    <div id="top-text-container">Tutaj pojawi siÄ™ tekst</div>
    <div class="canvas-container">
        <canvas id="octogramCanvas"></canvas>
        <div class="vertex-icon" data-index="0"></div>
        <div class="vertex-icon" data-index="1"></div>
        <div class="vertex-icon" data-index="2"></div>
        <div class="vertex-icon" data-index="3"></div>
        <div class="vertex-icon" data-index="4"></div>
        <div class="vertex-icon" data-index="5"></div>
        <div class="vertex-icon" data-index="6"></div>
        <div class="vertex-icon" data-index="7"></div>
    </div>
    <div class="button-row">
        <button id="skipButton" class="skip-btn">PomiÅ„</button>
        <button id="resetButton" class="reset-btn">Resetuj</button>
    </div>
    <div id="history" class="history"></div>
    <div class="button-row">
        <input type="text" id="spellInput" placeholder="WprowadÅº kod zaklÄ™cia (np. 32457061)">
        <button id="loadSpellButton">ZaÅ‚aduj zaklÄ™cie</button>
    </div>

    <script>
        const canvas = document.getElementById('octogramCanvas');
        const ctx = canvas.getContext('2d');

        let center = { x: 0, y: 0 };
        let radius = 0;
        let points = [];


        function resizeCanvasAndGeometry() {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            const cssSize = Math.min(rect.width, rect.height);

            canvas.width = cssSize * dpr;
            canvas.height = cssSize * dpr;

            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.scale(dpr, dpr);

            center = { x: cssSize / 2, y: cssSize / 2 };
            radius = cssSize * 0.34;

            points = [];
            for (let i = 0; i < 8; i++) {
                const angle = (Math.PI / 4) * i - Math.PI / 2;
                points.push({
                    x: center.x + radius * Math.cos(angle),
                    y: center.y + radius * Math.sin(angle)
                });
            }
        }


        let dragging = false;
        let startPoint = null;
        let currentMouse = { x: 0, y: 0 };
        let lastEndPoint = null;
        let hasDragged = false;
        let actionCount = 0;
        let visitedPoints = [];
        let historyShown = false;
        let actions = [];
        let pointDataLog = [];
        let totalManaCost = 0;
        let spellCode = [];
        let lastTouchOffset = null;

        const ACTION_LIMIT = 8;
        const toggleThemeBtn = document.getElementById('toggleTheme');
        const connectionMap = new Map();

        function getActionColor(index) {
            const variable = getComputedStyle(document.body).getPropertyValue(`--color-action-${index}`);
            return variable.trim() || 'black';
        }

        function normalizePoint(p) {
            return { x: p.x / canvas.width, y: p.y / canvas.height };
        }

        function denormalizePoint(p) {
            return { x: p.x * canvas.width, y: p.y * canvas.height };
        }

        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        function drawBaseLines() {
            const baseLineWidth = radius * 0.003;

            ctx.strokeStyle = 'white';
            ctx.lineWidth = baseLineWidth;

            for (let i = 0; i < points.length; i++) {
                for (let j = i + 1; j < points.length; j++) {
                    ctx.beginPath();
                    ctx.moveTo(points[i].x, points[i].y);
                    ctx.lineTo(points[j].x, points[j].y);
                    ctx.stroke();
                }
            }

            ctx.beginPath();
            ctx.arc(center.x, center.y, radius, 0, 2 * Math.PI);
            ctx.strokeStyle = 'white';
            ctx.lineWidth = baseLineWidth;
            ctx.stroke();
        }

        function drawActions() {
            const markerCounts = {};
            const currentCount = {};
            const connectionMap = {};

            for (const action of actions) {
                if (action.type === 'line') {
                    let from = denormalizePoint(action.from);
                    const to = denormalizePoint(action.to);

                    const fromKey = `${from.x},${from.y}`;
                    let markerCount = 0;

                    const actionIndex = actions.indexOf(action);
                    for (let i = 0; i < actionIndex; i++) {
                        const a = actions[i];
                        if ((a.type === 'marker' || a.type === 'skip')) {
                            const pt = denormalizePoint(a.point);
                            if (Math.abs(pt.x - from.x) < 1e-2 && Math.abs(pt.y - from.y) < 1e-2) {
                                markerCount++;
                            }
                        }
                    }


                    if (markerCount > 0) {
                        const dx = to.x - from.x;
                        const dy = to.y - from.y;
                        const length = Math.sqrt(dx * dx + dy * dy);
                        if (length > 0) {
                            const unitX = dx / length;
                            const unitY = dy / length;

                            const baseRingRadius = radius * 0.07;
                            const ringSpacing = radius * 0.035;
                            const arcRadius = baseRingRadius + (markerCount - 1) * ringSpacing;

                            from.x += unitX * arcRadius;
                            from.y += unitY * arcRadius;
                        }
                    }

                    const indexFrom = getPointIndex(denormalizePoint(action.from));
                    const indexTo = getPointIndex(denormalizePoint(action.to));
                    if (indexFrom === -1 || indexTo === -1) continue;

                    const key = [indexFrom, indexTo].sort().join('-');
                    if (!connectionMap[key]) connectionMap[key] = [];
                    connectionMap[key].push({ action, from, to });
                }
            }

            for (const key in connectionMap) {
                const group = connectionMap[key];
                const [indexA, indexB] = key.split('-').map(Number);
                const ptA = points[indexA];
                const ptB = points[indexB];
                const dx = ptB.x - ptA.x;
                const dy = ptB.y - ptA.y;
                const mid = { x: (ptA.x + ptB.x) / 2, y: (ptA.y + ptB.y) / 2 };
                const length = Math.sqrt(dx * dx + dy * dy);
                const nx = -dy / length;
                const ny = dx / length;

                const baseOffset = radius * 0.15;

                group.forEach((item, i) => {
                    const curveOffset = (i - (group.length - 1) / 2) * baseOffset;
                    const cx = mid.x + nx * curveOffset;
                    const cy = mid.y + ny * curveOffset;

                    ctx.beginPath();
                    ctx.moveTo(item.from.x, item.from.y);
                    ctx.quadraticCurveTo(cx, cy, item.to.x, item.to.y);
                    ctx.strokeStyle = item.action.color;
                    ctx.lineWidth = radius * 0.012;
                    ctx.stroke();
                });
            }

            for (const action of actions) {
                if (action.type === 'marker' || action.type === 'skip') {
                    const point = denormalizePoint(action.point);
                    const key = `${action.point.x},${action.point.y}`;
                    const ringIndex = currentCount[key] || 0;

                    const baseRingRadius = radius * 0.07;
                    const ringSpacing = radius * 0.035;
                    const arcRadius = baseRingRadius + ringIndex * ringSpacing;

                    ctx.beginPath();
                    if (action.type === 'skip') {
                        ctx.setLineDash([radius * 0.015, radius * 0.07]);
                    }

                    ctx.arc(point.x, point.y, arcRadius, 0, 2 * Math.PI);
                    ctx.strokeStyle = action.color;
                    ctx.lineWidth = action.type === 'skip' ? radius * 0.009 : radius * 0.012;
                    ctx.stroke();
                    ctx.setLineDash([]);

                    currentCount[key] = ringIndex + 1;
                    markerCounts[key] = (markerCounts[key] || 0) + 1;
                }
            }
        }


        function drawVertices() {
            const vertexRadius = radius * 0.03;
            const lineWidth = radius * 0.0075;

            for (const pt of points) {
                ctx.beginPath();
                ctx.arc(pt.x, pt.y, vertexRadius, 0, 2 * Math.PI);
                ctx.strokeStyle = 'white';
                ctx.lineWidth = lineWidth;
                ctx.stroke();
            }
        }

        function drawTempLine() {
            if (dragging && startPoint) {
                let fromX = startPoint.x;
                let fromY = startPoint.y;
                const fromKey = `${startPoint.x},${startPoint.y}`;
                let markerCount = 0;

                for (const action of actions) {
                    if (action.type === 'marker' || action.type === 'skip') {
                        const pt = denormalizePoint(action.point);
                        if (`${pt.x},${pt.y}` === fromKey) {
                            markerCount++;
                        }
                    }
                }

                const baseRingRadius = radius * 0.07;
                const ringSpacing = radius * 0.035;
                const arcRadius = baseRingRadius + (markerCount - 1) * ringSpacing;
                const lineWidth = radius * 0.012;

                if (markerCount > 0) {
                    const dx = currentMouse.x - fromX;
                    const dy = currentMouse.y - fromY;
                    const length = Math.sqrt(dx * dx + dy * dy);
                    const unitX = dx / length;
                    const unitY = dy / length;

                    fromX += unitX * arcRadius;
                    fromY += unitY * arcRadius;
                }

                ctx.beginPath();
                ctx.moveTo(fromX, fromY);
                ctx.lineTo(currentMouse.x, currentMouse.y);
                ctx.strokeStyle = 'black';
                ctx.lineWidth = lineWidth;
                ctx.stroke();
            }
        }

        function drawOctogram() {
            resizeCanvasAndGeometry();
            clearCanvas();
            drawBaseLines();
            drawActions();
            drawVertices();
            drawTempLine();
        }

        function updateThemeIcon() {
            const isLight = document.body.classList.contains('light-mode');
            toggleThemeBtn.textContent = isLight ? 'ðŸŒ™' : 'ðŸŒž';
        }

        function updateVertexIcons(stepIndex) {
            const icons = document.querySelectorAll('.vertex-icon');

            const offset = radius * 0.20;
            const baseIconSize = radius * 0.18;

            const stepScaling = {
                0: 1.3,
                1: 1.3,
                2: 1.2,
                3: 1.2,
                4: 1.5,
                5: 1.5,
                6: 1.5,
                7: 1.5
            };

            const scale = stepScaling[stepIndex] ?? 1.0;
            const iconSize = baseIconSize * scale;
            const fontSize = iconSize * 0.45;

            const cssWidth = canvas.clientWidth;
            const cssHeight = canvas.clientHeight;

            const stepTitles = [
                "NATURA",
                "MOC",
                "EFEKT",
                "FORMA",
                "ODLEGLOÅšÄ†",
                "OBSZAR",
                "CZAS TRWANIA",
                "OPÃ“Å¹NIENIE"
            ];
            const titleEl = document.getElementById("top-text-container");
            if (titleEl && stepIndex >= 0 && stepIndex < stepTitles.length) {
                titleEl.textContent = stepTitles[stepIndex];
            }

            icons.forEach((el, index) => {
                const base = points[index];
                const angle = (Math.PI / 4) * index - Math.PI / 2;

                const x = base.x + Math.cos(angle) * offset;
                const y = base.y + Math.sin(angle) * offset;

                const leftPercent = (x / cssWidth) * 100;
                const topPercent = (y / cssHeight) * 100;

                const iconStep = Math.min(stepIndex, 7);
                const isTextStep = stepIndex >= 2;

                el.className = `vertex-icon step-${stepIndex}`;
                el.style.left = `${leftPercent}%`;
                el.style.top = `${topPercent}%`;
                el.style.width = `${iconSize}px`;
                el.style.height = `${iconSize}px`;
                el.style.fontSize = `${fontSize}px`;
                el.style.lineHeight = `${iconSize}px`;

                if (isTextStep) {
                    if (stepIndex === 2) {
                        el.textContent = ["Losuj", "Przemiesc", "Zaatakuj", "Ulecz", "Obron", "Okryj", "Pokaz", "Zniszcz"][index];
                    } else if (stepIndex === 3) {
                        el.textContent = ["Kreacja", "Dotyk", "Wybuch", "Plama", "Sciana", "Pocisk", "Iluzja", "Przywolanie"][index];
                    } else {
                        el.textContent = `${index + 2}`;
                    }
                    el.style.backgroundImage = 'none';
                } else {
                    el.textContent = '';
                    el.style.backgroundImage = `url('./static/icons/icon_${index}_${iconStep}.png')`;
                }
            });
        }


        function getPointIndex(pt) {
            for (let i = 0; i < points.length; i++) {
                if (Math.abs(points[i].x - pt.x) < 1e-2 && Math.abs(points[i].y - pt.y) < 1e-2) {
                    return i;
                }
            }
            return -1;
        }

        function generatePointInfo(index) {
            const dataTypes = [
                ['elementem chaosu ', 'elementem Å›wiatÅ‚a ', 'elemetem ognia ', 'elementem wody ',
                    'elementem ziemii ', 'elementem powietrza ', 'elementem psychicznym ', 'elementem Å›mierci '],
                ['za K100.', 'za K2.', 'za K4.', 'za K6.', 'za K8.', 'za K10.', 'za K12.', 'za K20.'],
                ['wylosuj ', 'przemieÅ›Ä‡ ', 'zaatakuj ', 'ulecz ', 'obroÅ„ ', 'okryj ', 'pokaÅ¼ ', 'zniszcz '],
                ['z uÅ¼yciem kreacji ', 'z uÅ¼yciem dotyku ', 'z uÅ¼yciem wybuchu ', 'z uÅ¼yciem plamy ',
                    'z uÅ¼yciem Å›ciany ', 'z uÅ¼yciem pocisku ', 'z uÅ¼yciem iluzji ', 'z uÅ¼yciem przywoÅ‚ania '],
                ['i w zasiÄ™gu 9, ', ' i w zasiÄ™gu 2, ', 'i w zasiÄ™gu 3, ', 'i w zasiÄ™gu 4, ',
                    'i w zasiÄ™gu 5, ', 'i w zasiÄ™gu 6, ', 'i w zasiÄ™gu 7, ', 'i w zasiÄ™gu 8, ',
                    'i w zasiÄ™gu 1, ' ],
                ['w obszarze 9 pÃ³l ', 'w obszarze 2 pÃ³l ', 'w obszarze 3 pÃ³l ', 'w obszarze 4 pÃ³l ',
                    'w obszarze 5 pÃ³l ', 'w obszarze 6 pÃ³l ', 'w obszarze 7 pÃ³l ', 'w obszarze 8 pÃ³l ',
                    'w obszarze 1 pola '],
                ['przez nastÄ™pne 9, ', 'przez nastÄ™pne 2, ', 'przez nastÄ™pne 3, ',
                    'przez nastÄ™pne 4, ', 'przez nastÄ™pne 5, ', 'przez nastÄ™pne 6, ',
                    'przez nastÄ™pne 7, ', 'przez nastÄ™pne 8, ', 'przez 1, '],
                ['Za 9 tur, ', 'Za 2 tury, ', 'Za 3 tury, ', 'Za 4 tury, ', 'Za 5 tur, ', 'Za 6 tur, ', 'Za 7 tur, ',
                    'Za 8 tur, ', 'W tej turze, ']
            ];

            return dataTypes[index % dataTypes.length];
        }

        function showHistory() {
            const historyDiv = document.getElementById('history');

            const customOrder = [7, 6, 5, 4, 3, 2, 0, 1];

            const orderedInfo = customOrder
                .map(i => pointDataLog[i]?.info ?? '')
                .join('');

            const spellLine = spellCode.join('');

            historyDiv.innerHTML = `
                <h2>CaÅ‚kowity koszt many:</h2>
                <p style="font-size: 1.5em;">${totalManaCost}</p>
                <h2>Opis zaklÄ™cia:</h2>
                <p style="font-size: 1.5em;">${orderedInfo}</p>
                <h3>Kod zaklÄ™cia:</h3>
                <p style="font-size: 1.2em;">${spellLine}</p>
            `;
        }

        function finalizeDrawing() {
            actions.forEach(action => {
                action.color = 'black';
            });

            document.querySelectorAll('.vertex-icon').forEach(img => {
                img.classList.add('hidden');
            });
            document.getElementById("top-text-container").classList.add("hidden");

            drawOctogram();
        }


        function resetState() {
            visitedPoints = [];
            actions = [];
            pointDataLog = [];
            spellCode = [];
            actionCount = 0;
            totalManaCost = 0;
            historyShown = false;
            lastEndPoint = null;
            startPoint = null;
            dragging = false;
            currentMouse = { x: 0, y: 0 };

            document.getElementById('history').innerHTML = '';
            document.querySelectorAll('.vertex-icon').forEach(img => {
                img.classList.remove('hidden');
            });
            document.getElementById("top-text-container").classList.remove("hidden");

            drawOctogram();
            updateVertexIcons(actionCount);
        }

        function loadSpellFromCode(code) {
            resetState();

            const digits = code.split('').map(d => parseInt(d, 10));

            if (digits.length !== 8 || digits.some(d => isNaN(d) || d < 0 || d > 9)) {
                alert("Kod zaklÄ™cia musi zawieraÄ‡ dokÅ‚adnie 8 cyfr od 0 do 9.");
                return;
            }

            let currentPoint = points[0];
            lastEndPoint = currentPoint;

            for (let i = 0; i < digits.length; i++) {
                const val = digits[i];
                const prevVal = i > 0 ? digits[i - 1] : null;
                const color = getActionColor(actionCount);
                const infoSet = generatePointInfo(i);

                if (i === 0 && val === 8) {
                    pointDataLog.push({ point: currentPoint, info: infoSet[7] });
                    spellCode.push(8);
                    totalManaCost += 8;
                    actions.push({
                        type: 'marker',
                        color,
                        point: normalizePoint(currentPoint)
                    });
                } else if (val === 0) {
                    pointDataLog.push({ point: currentPoint, info: infoSet[8] });
                    spellCode.push(0);
                    actions.push({
                        type: 'skip',
                        color,
                        point: normalizePoint(currentPoint)
                    });
                } else {
                    const mappedIndex = (val === 8) ? 0 : val;

                    if (mappedIndex < 0 || mappedIndex > 7) continue;

                    const targetPoint = points[mappedIndex];
                    const manaCost = (val === 8) ? 8 : val;

                    if (val === prevVal) {
                        pointDataLog.push({ point: currentPoint, info: infoSet[mappedIndex] });
                        spellCode.push(val);
                        totalManaCost += manaCost;
                        actions.push({
                            type: 'marker',
                            color,
                            point: normalizePoint(currentPoint)
                        });
                    } else {
                        pointDataLog.push({ point: targetPoint, info: infoSet[mappedIndex] });
                        spellCode.push(val);
                        totalManaCost += manaCost;
                        actions.push({
                            type: 'line',
                            color,
                            from: normalizePoint(currentPoint),
                            to: normalizePoint(targetPoint)
                        });

                        currentPoint = targetPoint;
                        lastEndPoint = targetPoint;
                    }
                }

                actionCount += 1;
            }

            showHistory();
            finalizeDrawing();
        }

        function disableScroll() {
            canvas.style.touchAction = 'none';
            document.body.addEventListener('touchmove', preventDefault, { passive: false });
        }

        function enableScroll() {
            canvas.style.touchAction = '';
            document.body.removeEventListener('touchmove', preventDefault);
        }

        function preventDefault(e) {
            e.preventDefault();
        }

        function getEventOffset(e) {
            if (e.touches && e.touches.length > 0) {
                const rect = canvas.getBoundingClientRect();
                return {
                    offsetX: e.touches[0].clientX - rect.left,
                    offsetY: e.touches[0].clientY - rect.top
                };
            } else {
                return { offsetX: e.offsetX, offsetY: e.offsetY };
            }
        }

        function onDown(e) {
            e.preventDefault();
            disableScroll();
            const { offsetX, offsetY } = getEventOffset(e);
            hasDragged = false;
            const touchThreshold = radius * 0.20;

            for (const pt of points) {
                const dx = pt.x - offsetX;
                const dy = pt.y - offsetY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < touchThreshold) {
                    const isFirstAction = actionCount === 0;
                    const isStartAllowed = isFirstAction ? pt === points[0] : (lastEndPoint === null || (pt.x === lastEndPoint.x && pt.y === lastEndPoint.y));
                    if (isStartAllowed) {
                        startPoint = pt;
                        dragging = true;
                        break;
                    }
                }
            }
        }

        function onMove(e) {
            if (!dragging) return;
            e.preventDefault();
            hasDragged = true;

            const { offsetX, offsetY } = getEventOffset(e);
            currentMouse = { x: offsetX, y: offsetY };

            if (e.touches && e.touches.length > 0) {
                lastTouchOffset = { offsetX, offsetY };
            }

            drawOctogram();
        }

        function onUp(e) {
            e.preventDefault();
            enableScroll();
            if (!dragging || !startPoint) return;

            dragging = false;

            let offsetX, offsetY;
            const touchThreshold = radius * 0.20;

            if (e.type === 'touchend' && lastTouchOffset) {
                ({ offsetX, offsetY } = lastTouchOffset);
            } else {
                ({ offsetX, offsetY } = getEventOffset(e));
            }

            if (!hasDragged) {
                handleTap(offsetX, offsetY);
                startPoint = null;
                return;
            }

            if (actionCount >= ACTION_LIMIT) {
                startPoint = null;
                drawOctogram();
                return;
            }

            for (const pt of points) {
                const dx = pt.x - offsetX;
                const dy = pt.y - offsetY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < touchThreshold && (pt.x !== startPoint.x || pt.y !== startPoint.y)) {
                    const color = getActionColor(actionCount);
                    const from = normalizePoint(startPoint);
                    const to = normalizePoint(pt);
                    const index = getPointIndex(pt);
                    const infoSet = generatePointInfo(actionCount);

                    if (index !== -1) {
                        pointDataLog.push({
                            point: pt,
                            info: infoSet[index]
                        });
                    }

                    actions.push({
                        type: 'line',
                        from,
                        to,
                        color
                    });

                    lastEndPoint = pt;
                    visitedPoints.push(pt);
                    if (index !== -1) totalManaCost += (index === 0 ? 8 : index);
                    if (index !== -1) spellCode.push(index === 0 ? 8 : index);
                    actionCount += 1;
                    break;
                }
            }

            startPoint = null;
            drawOctogram();
            updateVertexIcons(actionCount);


            if (actionCount >= ACTION_LIMIT && !historyShown) {
                showHistory();
                finalizeDrawing();
                historyShown = true;
            }
        }

        function handleTap(offsetX, offsetY) {
            if (actionCount >= ACTION_LIMIT) return;

            const isFirstAction = actionCount === 0;
            const allowedTapPoint = isFirstAction ? points[0] : lastEndPoint;
            if (!allowedTapPoint) return;

            const touchThreshold = radius * 0.20;

            for (const pt of points) {
                const dx = pt.x - offsetX;
                const dy = pt.y - offsetY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < touchThreshold && pt.x === allowedTapPoint.x && pt.y === allowedTapPoint.y) {
                    const color = getActionColor(actionCount);
                    const index = getPointIndex(pt);
                    const infoSet = generatePointInfo(actionCount);

                    if (index !== -1) {
                        pointDataLog.push({ point: pt, info: infoSet[index] });
                        totalManaCost += index === 0 ? 8 : index;
                        spellCode.push(index === 0 ? 8 : index);
                    }

                    actions.push({
                        type: 'marker',
                        point: normalizePoint(pt),
                        color
                    });

                    visitedPoints.push(pt);
                    lastEndPoint = pt;
                    actionCount += 1;
                    drawOctogram();
                    updateVertexIcons(actionCount);

                    if (actionCount >= ACTION_LIMIT && !historyShown) {
                        showHistory();
                        finalizeDrawing();
                        historyShown = true;
                    }
                    break;
                }
            }
        }

        function skipAction() {
            if (actionCount >= ACTION_LIMIT || historyShown) return;

            if (actionCount < 4) {
                alert("Aby pominÄ…Ä‡, musisz najpierw wykonaÄ‡ co najmniej 4 akcje.");
                return;
            }

            const color = getActionColor(actionCount);

            if (lastEndPoint) {
                const index = getPointIndex(lastEndPoint);
                const infoSet = generatePointInfo(actionCount);

                if (index !== -1) {
                    pointDataLog.push({
                        point: lastEndPoint,
                        info: infoSet[8]
                    });
                }

                actions.push({
                    type: 'skip',
                    color,
                    point: normalizePoint(lastEndPoint)
                });

                spellCode.push(0);
            }

            actionCount += 1;

            if (actionCount >= ACTION_LIMIT && !historyShown) {
                showHistory();
                finalizeDrawing();
                historyShown = true;
            }

            drawOctogram();
            updateVertexIcons(actionCount);
        }

        canvas.addEventListener('mousedown', onDown);
        canvas.addEventListener('touchstart', onDown);

        canvas.addEventListener('mousemove', onMove);
        canvas.addEventListener('touchmove', onMove);

        canvas.addEventListener('mouseup', onUp);
        canvas.addEventListener('touchend', onUp);

        document.getElementById('resetButton').addEventListener('click', resetState);
        document.getElementById('skipButton').addEventListener('click', skipAction);
        document.getElementById('loadSpellButton').addEventListener('click', () => {
            const code = document.getElementById('spellInput').value.trim();
            loadSpellFromCode(code);
        });

        window.addEventListener('resize', () => {
            resizeCanvasAndGeometry();
            drawOctogram();
            updateVertexIcons(actionCount);
        });

        updateThemeIcon();

        toggleThemeBtn.addEventListener('click', () => {
            document.body.classList.toggle('light-mode');
            updateThemeIcon();
            drawOctogram();
        });

        resizeCanvasAndGeometry();
        drawOctogram();
        updateVertexIcons(actionCount);

    </script>
</body>
</html>
