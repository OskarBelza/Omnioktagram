<!DOCTYPE html>
<html lang="pl">
<link rel="preload" href="static/fonts/Centurion.ttf" as="font" type="font/ttf" crossorigin="anonymous">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Omnioktagram</title>
    <link rel="stylesheet" href="static/styles.css">
    <style>
    @font-face {
      font-family: 'Centurion';
      src: url('static/fonts/Centurion.ttf') format('truetype');
    }
    </style>
</head>
<body>
    <button id="toggleTheme" class="theme-toggle" title="Przecz tryb">
        
    </button>
    <h1>Omnioktagram</h1>
    <div id="top-text-container">Tutaj pojawi si tekst</div>
    <div class="canvas-container">
        <canvas id="octogramCanvas"></canvas>
        <div class="vertex-icon" data-index="0"></div>
        <div class="vertex-icon" data-index="1"></div>
        <div class="vertex-icon" data-index="2"></div>
        <div class="vertex-icon" data-index="3"></div>
        <div class="vertex-icon" data-index="4"></div>
        <div class="vertex-icon" data-index="5"></div>
        <div class="vertex-icon" data-index="6"></div>
        <div class="vertex-icon" data-index="7"></div>
    </div>
    <div class="button-row">
        <button id="skipButton" class="skip-btn">Pomi</button>
        <button id="resetButton" class="reset-btn">Resetuj</button>
    </div>
    <div id="history" class="history"></div>
    <div class="button-row">
        <input type="text" id="spellInput" placeholder="Wprowad藕 kod zaklcia (np. 32457061)">
        <button id="loadSpellButton">Zaaduj zaklcie</button>
    </div>

    <script>
        const canvas = document.getElementById('octogramCanvas');
        const ctx = canvas.getContext('2d');

        let center = { x: 0, y: 0 };
        let radius = 0;
        let points = [];


        function resizeCanvasAndGeometry() {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            const cssSize = Math.min(rect.width, rect.height);

            canvas.width = cssSize * dpr;
            canvas.height = cssSize * dpr;

            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.scale(dpr, dpr);

            center = { x: cssSize / 2, y: cssSize / 2 };
            radius = cssSize * 0.34;

            points = [];
            for (let i = 0; i < 8; i++) {
                const angle = (Math.PI / 4) * i - Math.PI / 2;
                points.push({
                    x: center.x + radius * Math.cos(angle),
                    y: center.y + radius * Math.sin(angle)
                });
            }
        }


        let dragging = false;
        let startPoint = null;
        let currentMouse = { x: 0, y: 0 };
        let lastEndPoint = null;
        let hasDragged = false;
        let actionCount = 0;
        let visitedPoints = [];
        let historyShown = false;
        let actions = [];
        let pointDataLog = [];
        let totalManaCost = 0;
        let spellCode = [];
        let lastTouchOffset = null;

        const ACTION_LIMIT = 8;
        const toggleThemeBtn = document.getElementById('toggleTheme');
        const connectionMap = new Map();

        function getActionColor(index) {
            const variable = getComputedStyle(document.body).getPropertyValue(`--color-action-${index}`);
            return variable.trim() || 'black';
        }

        function normalizePoint(p) {
            return { x: p.x / canvas.width, y: p.y / canvas.height };
        }

        function denormalizePoint(p) {
            return { x: p.x * canvas.width, y: p.y * canvas.height };
        }

        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        function drawBaseLines() {
            const baseLineWidth = radius * 0.003;

            ctx.strokeStyle = 'white';
            ctx.lineWidth = baseLineWidth;

            for (let i = 0; i < points.length; i++) {
                for (let j = i + 1; j < points.length; j++) {
                    ctx.beginPath();
                    ctx.moveTo(points[i].x, points[i].y);
                    ctx.lineTo(points[j].x, points[j].y);
                    ctx.stroke();
                }
            }

            ctx.beginPath();
            ctx.arc(center.x, center.y, radius, 0, 2 * Math.PI);
            ctx.strokeStyle = 'white';
            ctx.lineWidth = baseLineWidth;
            ctx.stroke();
        }

        function drawActions() {
            const markerCounts = {};
            const currentCount = {};
            const connectionMap = {};

            for (const action of actions) {
                if (action.type === 'line') {
                    let from = denormalizePoint(action.from);
                    const to = denormalizePoint(action.to);

                    const fromKey = `${from.x},${from.y}`;
                    let markerCount = 0;

                    const actionIndex = actions.indexOf(action);
                    for (let i = 0; i < actionIndex; i++) {
                        const a = actions[i];
                        if ((a.type === 'marker' || a.type === 'skip')) {
                            const pt = denormalizePoint(a.point);
                            if (Math.abs(pt.x - from.x) < 1e-2 && Math.abs(pt.y - from.y) < 1e-2) {
                                markerCount++;
                            }
                        }
                    }


                    if (markerCount > 0) {
                        const dx = to.x - from.x;
                        const dy = to.y - from.y;
                        const length = Math.sqrt(dx * dx + dy * dy);
                        if (length > 0) {
                            const unitX = dx / length;
                            const unitY = dy / length;

                            const baseRingRadius = radius * 0.07;
                            const ringSpacing = radius * 0.035;
                            const arcRadius = baseRingRadius + (markerCount - 1) * ringSpacing;

                            from.x += unitX * arcRadius;
                            from.y += unitY * arcRadius;
                        }
                    }

                    const indexFrom = getPointIndex(denormalizePoint(action.from));
                    const indexTo = getPointIndex(denormalizePoint(action.to));
                    if (indexFrom === -1 || indexTo === -1) continue;

                    const key = [indexFrom, indexTo].sort().join('-');
                    if (!connectionMap[key]) connectionMap[key] = [];
                    connectionMap[key].push({ action, from, to });
                }
            }

            for (const key in connectionMap) {
                const group = connectionMap[key];
                const [indexA, indexB] = key.split('-').map(Number);
                const ptA = points[indexA];
                const ptB = points[indexB];
                const dx = ptB.x - ptA.x;
                const dy = ptB.y - ptA.y;
                const mid = { x: (ptA.x + ptB.x) / 2, y: (ptA.y + ptB.y) / 2 };
                const length = Math.sqrt(dx * dx + dy * dy);
                const nx = -dy / length;
                const ny = dx / length;

                const baseOffset = radius * 0.15;

                group.forEach((item, i) => {
                    const curveOffset = (i - (group.length - 1) / 2) * baseOffset;
                    const cx = mid.x + nx * curveOffset;
                    const cy = mid.y + ny * curveOffset;

                    ctx.beginPath();
                    ctx.moveTo(item.from.x, item.from.y);
                    ctx.quadraticCurveTo(cx, cy, item.to.x, item.to.y);
                    ctx.strokeStyle = item.action.color;
                    ctx.lineWidth = radius * 0.012;
                    ctx.stroke();
                });
            }

            for (const action of actions) {
                if (action.type === 'marker' || action.type === 'skip') {
                    const point = denormalizePoint(action.point);
                    const key = `${action.point.x},${action.point.y}`;
                    const ringIndex = currentCount[key] || 0;

                    const baseRingRadius = radius * 0.07;
                    const ringSpacing = radius * 0.035;
                    const arcRadius = baseRingRadius + ringIndex * ringSpacing;

                    ctx.beginPath();
                    if (action.type === 'skip') {
                        ctx.setLineDash([radius * 0.015, radius * 0.07]);
                    }

                    ctx.arc(point.x, point.y, arcRadius, 0, 2 * Math.PI);
                    ctx.strokeStyle = action.color;
                    ctx.lineWidth = action.type === 'skip' ? radius * 0.009 : radius * 0.012;
                    ctx.stroke();
                    ctx.setLineDash([]);

                    currentCount[key] = ringIndex + 1;
                    markerCounts[key] = (markerCounts[key] || 0) + 1;
                }
            }
        }


        function drawVertices() {
            const vertexRadius = radius * 0.03;
            const lineWidth = radius * 0.0075;

            for (const pt of points) {
                ctx.beginPath();
                ctx.arc(pt.x, pt.y, vertexRadius, 0, 2 * Math.PI);
                ctx.strokeStyle = 'white';
                ctx.lineWidth = lineWidth;
                ctx.stroke();
            }
        }

        function drawTempLine() {
            if (dragging && startPoint) {
                let fromX = startPoint.x;
                let fromY = startPoint.y;
                const fromKey = `${startPoint.x},${startPoint.y}`;
                let markerCount = 0;

                for (const action of actions) {
                    if (action.type === 'marker' || action.type === 'skip') {
                        const pt = denormalizePoint(action.point);
                        if (`${pt.x},${pt.y}` === fromKey) {
                            markerCount++;
                        }
                    }
                }

                const baseRingRadius = radius * 0.07;
                const ringSpacing = radius * 0.035;
                const arcRadius = baseRingRadius + (markerCount - 1) * ringSpacing;
                const lineWidth = radius * 0.012;

                if (markerCount > 0) {
                    const dx = currentMouse.x - fromX;
                    const dy = currentMouse.y - fromY;
                    const length = Math.sqrt(dx * dx + dy * dy);
                    const unitX = dx / length;
                    const unitY = dy / length;

                    fromX += unitX * arcRadius;
                    fromY += unitY * arcRadius;
                }

                ctx.beginPath();
                ctx.moveTo(fromX, fromY);
                ctx.lineTo(currentMouse.x, currentMouse.y);
                ctx.strokeStyle = 'black';
                ctx.lineWidth = lineWidth;
                ctx.stroke();
            }
        }

        function drawOctogram() {
            resizeCanvasAndGeometry();
            clearCanvas();
            drawBaseLines();
            drawActions();
            drawVertices();
            drawTempLine();
        }

        function updateThemeIcon() {
            const isLight = document.body.classList.contains('light-mode');
            toggleThemeBtn.textContent = isLight ? '' : '';
        }

        function updateVertexIcons(stepIndex) {
            const icons = document.querySelectorAll('.vertex-icon');

            const offset = radius * 0.20;
            const baseIconSize = radius * 0.18;

            const stepScaling = {
                0: 1.3,
                1: 1.3,
                2: 1.2,
                3: 1.2,
                4: 1.5,
                5: 1.5,
                6: 1.5,
                7: 1.5
            };

            const scale = stepScaling[stepIndex] ?? 1.0;
            const iconSize = baseIconSize * scale;
            const fontSize = iconSize * 0.45;

            const cssWidth = canvas.clientWidth;
            const cssHeight = canvas.clientHeight;

            const stepTitles = [
                "NATURA",
                "MOC",
                "EFEKT",
                "FORMA",
                "ODLEGLO",
                "OBSZAR",
                "CZAS TRWANIA",
                "OP殴NIENIE"
            ];
            const titleEl = document.getElementById("top-text-container");
            if (titleEl && stepIndex >= 0 && stepIndex < stepTitles.length) {
                titleEl.textContent = stepTitles[stepIndex];
            }

            icons.forEach((el, index) => {
                const base = points[index];
                const angle = (Math.PI / 4) * index - Math.PI / 2;

                const x = base.x + Math.cos(angle) * offset;
                const y = base.y + Math.sin(angle) * offset;

                const leftPercent = (x / cssWidth) * 100;
                const topPercent = (y / cssHeight) * 100;

                const iconStep = Math.min(stepIndex, 7);
                const isTextStep = stepIndex >= 2;

                el.className = `vertex-icon step-${stepIndex}`;
                el.style.left = `${leftPercent}%`;
                el.style.top = `${topPercent}%`;
                el.style.width = `${iconSize}px`;
                el.style.height = `${iconSize}px`;
                el.style.fontSize = `${fontSize}px`;
                el.style.lineHeight = `${iconSize}px`;

                if (isTextStep) {
                    if (stepIndex === 2) {
                        el.textContent = ["Losuj", "Przemiesc", "Zaatakuj", "Ulecz", "Obron", "Okryj", "Pokaz", "Zniszcz"][index];
                    } else if (stepIndex === 3) {
                        el.textContent = ["Kreacja", "Dotyk", "Wybuch", "Plama", "Sciana", "Pocisk", "Iluzja", "Przywolanie"][index];
                    } else {
                        el.textContent = `${index + 2}`;
                    }
                    el.style.backgroundImage = 'none';
                } else {
                    el.textContent = '';
                    el.style.backgroundImage = `url('./static/icons/icon_${index}_${iconStep}.png')`;
                }
            });
        }


        function getPointIndex(pt) {
            for (let i = 0; i < points.length; i++) {
                if (Math.abs(points[i].x - pt.x) < 1e-2 && Math.abs(points[i].y - pt.y) < 1e-2) {
                    return i;
                }
            }
            return -1;
        }

        function generatePointInfo(index) {
            const dataTypes = [
                ['elementem chaosu ', 'elementem wiata ', 'elemetem ognia ', 'elementem wody ',
                    'elementem ziemii ', 'elementem powietrza ', 'elementem psychicznym ', 'elementem mierci '],
                ['za K100.', 'za K2.', 'za K4.', 'za K6.', 'za K8.', 'za K10.', 'za K12.', 'za K20.'],
                ['wylosuj ', 'przemie ', 'zaatakuj ', 'ulecz ', 'obro ', 'okryj ', 'poka偶 ', 'zniszcz '],
                ['z u偶yciem kreacji ', 'z u偶yciem dotyku ', 'z u偶yciem wybuchu ', 'z u偶yciem plamy ',
                    'z u偶yciem ciany ', 'z u偶yciem pocisku ', 'z u偶yciem iluzji ', 'z u偶yciem przywoania '],
                ['i w zasigu 9, ', ' i w zasigu 2, ', 'i w zasigu 3, ', 'i w zasigu 4, ',
                    'i w zasigu 5, ', 'i w zasigu 6, ', 'i w zasigu 7, ', 'i w zasigu 8, ',
                    'i w zasigu 1, ' ],
                ['w obszarze 9 p贸l ', 'w obszarze 2 p贸l ', 'w obszarze 3 p贸l ', 'w obszarze 4 p贸l ',
                    'w obszarze 5 p贸l ', 'w obszarze 6 p贸l ', 'w obszarze 7 p贸l ', 'w obszarze 8 p贸l ',
                    'w obszarze 1 pola '],
                ['przez nastpne 9, ', 'przez nastpne 2, ', 'przez nastpne 3, ',
                    'przez nastpne 4, ', 'przez nastpne 5, ', 'przez nastpne 6, ',
                    'przez nastpne 7, ', 'przez nastpne 8, ', 'przez 1, '],
                ['Za 9 tur, ', 'Za 2 tury, ', 'Za 3 tury, ', 'Za 4 tury, ', 'Za 5 tur, ', 'Za 6 tur, ', 'Za 7 tur, ',
                    'Za 8 tur, ', 'W tej turze, ']
            ];

            return dataTypes[index % dataTypes.length];
        }

        function showHistory() {
            const historyDiv = document.getElementById('history');

            const customOrder = [7, 6, 5, 4, 3, 2, 0, 1];

            const orderedInfo = customOrder
                .map(i => pointDataLog[i]?.info ?? '')
                .join('');

            const spellLine = spellCode.join('');

            historyDiv.innerHTML = `
                <h2>Cakowity koszt many:</h2>
                <p style="font-size: 1.5em;">${totalManaCost}</p>
                <h2>Opis zaklcia:</h2>
                <p style="font-size: 1.5em;">${orderedInfo}</p>
                <h3>Kod zaklcia:</h3>
                <p style="font-size: 1.2em;">${spellLine}</p>
            `;
        }

        function finalizeDrawing() {
            actions.forEach(action => {
                action.color = 'black';
            });

            document.querySelectorAll('.vertex-icon').forEach(img => {
                img.classList.add('hidden');
            });
            document.getElementById("top-text-container").classList.add("hidden");

            drawOctogram();
        }


        function resetState() {
            visitedPoints = [];
            actions = [];
            pointDataLog = [];
            spellCode = [];
            actionCount = 0;
            totalManaCost = 0;
            historyShown = false;
            lastEndPoint = null;
            startPoint = null;
            dragging = false;
            currentMouse = { x: 0, y: 0 };

            document.getElementById('history').innerHTML = '';
            document.querySelectorAll('.vertex-icon').forEach(img => {
                img.classList.remove('hidden');
            });
            document.getElementById("top-text-container").classList.remove("hidden");

            drawOctogram();
            updateVertexIcons(actionCount);
        }

        function loadSpellFromCode(code) {
            resetState();

            const digits = code.split('').map(d => parseInt(d, 10));

            if (digits.length !== 8 || digits.some(d => isNaN(d) || d < 0 || d > 9)) {
                alert("Kod zaklcia musi zawiera dokadnie 8 cyfr od 0 do 9.");
                return;
            }

            let currentPoint = points[0];
            lastEndPoint = currentPoint;

            for (let i = 0; i < digits.length; i++) {
                const val = digits[i];
                const prevVal = i > 0 ? digits[i - 1] : null;
                const color = getActionColor(actionCount);
                const infoSet = generatePointInfo(i);

                if (i === 0 && val === 8) {
                    pointDataLog.push({ point: currentPoint, info: infoSet[7] });
                    spellCode.push(8);
                    totalManaCost += 8;
                    actions.push({
                        type: 'marker',
                        color,
                        point: normalizePoint(currentPoint)
                    });
                } else if (val === 0) {
                    pointDataLog.push({ point: currentPoint, info: infoSet[8] });
                    spellCode.push(0);
                    actions.push({
                        type: 'skip',
                        color,
                        point: normalizePoint(currentPoint)
                    });
                } else {
                    const mappedIndex = (val === 8) ? 0 : val;

                    if (mappedIndex < 0 || mappedIndex > 7) continue;

                    const targetPoint = points[mappedIndex];
                    const manaCost = (val === 8) ? 8 : val;

                    if (val === prevVal) {
                        pointDataLog.push({ point: currentPoint, info: infoSet[mappedIndex] });
                        spellCode.push(val);
                        totalManaCost += manaCost;
                        actions.push({
                            type: 'marker',
                            color,
                            point: normalizePoint(currentPoint)
                        });
                    } else {
                        pointDataLog.push({ point: targetPoint, info: infoSet[mappedIndex] });
                        spellCode.push(val);
                        totalManaCost += manaCost;
                        actions.push({
                            type: 'line',
                            color,
                            from: normalizePoint(currentPoint),
                            to: normalizePoint(targetPoint)
                        });

                        currentPoint = targetPoint;
                        lastEndPoint = targetPoint;
                    }
                }

                actionCount += 1;
            }

            showHistory();
            finalizeDrawing();
        }

        function disableScroll() {
            canvas.style.touchAction = 'none';
            document.body.addEventListener('touchmove', preventDefault, { passive: false });
        }

        function enableScroll() {
            canvas.style.touchAction = '';
            document.body.removeEventListener('touchmove', preventDefault);
        }

        function preventDefault(e) {
            e.preventDefault();
        }

        function getEventOffset(e) {
            if (e.touches && e.touches.length > 0) {
                const rect = canvas.getBoundingClientRect();
                return {
                    offsetX: e.touches[0].clientX - rect.left,
                    offsetY: e.touches[0].clientY - rect.top
                };
            } else {
                return { offsetX: e.offsetX, offsetY: e.offsetY };
            }
        }

        function onDown(e) {
            e.preventDefault();
            disableScroll();
            const { offsetX, offsetY } = getEventOffset(e);
            hasDragged = false;
            const touchThreshold = radius * 0.20;

            for (const pt of points) {
                const dx = pt.x - offsetX;
                const dy = pt.y - offsetY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < touchThreshold) {
                    const isFirstAction = actionCount === 0;
                    const isStartAllowed = isFirstAction ? pt === points[0] : (lastEndPoint === null || (pt.x === lastEndPoint.x && pt.y === lastEndPoint.y));
                    if (isStartAllowed) {
                        startPoint = pt;
                        dragging = true;
                        break;
                    }
                }
            }
        }

        function onMove(e) {
            if (!dragging) return;
            e.preventDefault();
            hasDragged = true;

            const { offsetX, offsetY } = getEventOffset(e);
            currentMouse = { x: offsetX, y: offsetY };

            if (e.touches && e.touches.length > 0) {
                lastTouchOffset = { offsetX, offsetY };
            }

            drawOctogram();
        }

        function onUp(e) {
            e.preventDefault();
            enableScroll();
            if (!dragging || !startPoint) return;

            dragging = false;

            let offsetX, offsetY;
            const touchThreshold = radius * 0.20;

            if (e.type === 'touchend' && lastTouchOffset) {
                ({ offsetX, offsetY } = lastTouchOffset);
            } else {
                ({ offsetX, offsetY } = getEventOffset(e));
            }

            if (!hasDragged) {
                handleTap(offsetX, offsetY);
                startPoint = null;
                return;
            }

            if (actionCount >= ACTION_LIMIT) {
                startPoint = null;
                drawOctogram();
                return;
            }

            for (const pt of points) {
                const dx = pt.x - offsetX;
                const dy = pt.y - offsetY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < touchThreshold && (pt.x !== startPoint.x || pt.y !== startPoint.y)) {
                    const color = getActionColor(actionCount);
                    const from = normalizePoint(startPoint);
                    const to = normalizePoint(pt);
                    const index = getPointIndex(pt);
                    const infoSet = generatePointInfo(actionCount);

                    if (index !== -1) {
                        pointDataLog.push({
                            point: pt,
                            info: infoSet[index]
                        });
                    }

                    actions.push({
                        type: 'line',
                        from,
                        to,
                        color
                    });

                    lastEndPoint = pt;
                    visitedPoints.push(pt);
                    if (index !== -1) totalManaCost += (index === 0 ? 8 : index);
                    if (index !== -1) spellCode.push(index === 0 ? 8 : index);
                    actionCount += 1;
                    break;
                }
            }

            startPoint = null;
            drawOctogram();
            updateVertexIcons(actionCount);


            if (actionCount >= ACTION_LIMIT && !historyShown) {
                showHistory();
                finalizeDrawing();
                historyShown = true;
            }
        }

        function handleTap(offsetX, offsetY) {
            if (actionCount >= ACTION_LIMIT) return;

            const isFirstAction = actionCount === 0;
            const allowedTapPoint = isFirstAction ? points[0] : lastEndPoint;
            if (!allowedTapPoint) return;

            const touchThreshold = radius * 0.20;

            for (const pt of points) {
                const dx = pt.x - offsetX;
                const dy = pt.y - offsetY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < touchThreshold && pt.x === allowedTapPoint.x && pt.y === allowedTapPoint.y) {
                    const color = getActionColor(actionCount);
                    const index = getPointIndex(pt);
                    const infoSet = generatePointInfo(actionCount);

                    if (index !== -1) {
                        pointDataLog.push({ point: pt, info: infoSet[index] });
                        totalManaCost += index === 0 ? 8 : index;
                        spellCode.push(index === 0 ? 8 : index);
                    }

                    actions.push({
                        type: 'marker',
                        point: normalizePoint(pt),
                        color
                    });

                    visitedPoints.push(pt);
                    lastEndPoint = pt;
                    actionCount += 1;
                    drawOctogram();
                    updateVertexIcons(actionCount);

                    if (actionCount >= ACTION_LIMIT && !historyShown) {
                        showHistory();
                        finalizeDrawing();
                        historyShown = true;
                    }
                    break;
                }
            }
        }

        function skipAction() {
            if (actionCount >= ACTION_LIMIT || historyShown) return;

            if (actionCount < 4) {
                alert("Aby pomin, musisz najpierw wykona co najmniej 4 akcje.");
                return;
            }

            const color = getActionColor(actionCount);

            if (lastEndPoint) {
                const index = getPointIndex(lastEndPoint);
                const infoSet = generatePointInfo(actionCount);

                if (index !== -1) {
                    pointDataLog.push({
                        point: lastEndPoint,
                        info: infoSet[8]
                    });
                }

                actions.push({
                    type: 'skip',
                    color,
                    point: normalizePoint(lastEndPoint)
                });

                spellCode.push(0);
            }

            actionCount += 1;

            if (actionCount >= ACTION_LIMIT && !historyShown) {
                showHistory();
                finalizeDrawing();
                historyShown = true;
            }

            drawOctogram();
            updateVertexIcons(actionCount);
        }

        canvas.addEventListener('mousedown', onDown);
        canvas.addEventListener('touchstart', onDown);

        canvas.addEventListener('mousemove', onMove);
        canvas.addEventListener('touchmove', onMove);

        canvas.addEventListener('mouseup', onUp);
        canvas.addEventListener('touchend', onUp);

        document.getElementById('resetButton').addEventListener('click', resetState);
        document.getElementById('skipButton').addEventListener('click', skipAction);
        document.getElementById('loadSpellButton').addEventListener('click', () => {
            const code = document.getElementById('spellInput').value.trim();
            loadSpellFromCode(code);
        });

        window.addEventListener('resize', () => {
            resizeCanvasAndGeometry();
            drawOctogram();
            updateVertexIcons(actionCount);
        });

        updateThemeIcon();

        toggleThemeBtn.addEventListener('click', () => {
            document.body.classList.toggle('light-mode');
            updateThemeIcon();
            drawOctogram();
        });

        resizeCanvasAndGeometry();
        drawOctogram();
        updateVertexIcons(actionCount);

    </script>
</body>
</html>
